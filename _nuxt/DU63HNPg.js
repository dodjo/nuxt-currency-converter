var Y=Object.defineProperty;var G=(s,e,n)=>e in s?Y(s,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[e]=n;var C=(s,e,n)=>G(s,typeof e!="symbol"?e+"":e,n);import{a_ as J,g as M,a$ as b,Y as Q,b0 as B,b1 as W,b2 as X,ar as Z,a1 as K,m as z,ae as q,k as $,ac as F,aT as A,b3 as k,i as N,ad as ee,S as I,b4 as ae,b5 as te,J as se,O as L,h as ne,o as re,w as ie,C as ce,Q as oe,P as ue,b6 as le}from"./DqG09d24.js";const fe={trailing:!0};function de(s,e=25,n={}){if(n={...fe,...n},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let a,t,r=[],i,h;const c=(_,u)=>(i=he(s,_,u),i.finally(()=>{if(i=null,n.trailing&&h&&!t){const m=c(_,h);return h=null,m}}),i);return function(..._){return i?(n.trailing&&(h=_),i):new Promise(u=>{const m=!t&&n.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const o=n.leading?a:c(this,_);for(const v of r)v(o);r=[]},e),m?(a=c(this,_),u(a)):r.push(u)})}}async function he(s,e,n){return await s.apply(e,n)}const ye=[1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225],_e=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998],me="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",P=[];class ve{constructor(){C(this,"_data",new E);C(this,"_hash",new E([...ye]));C(this,"_nDataBytes",0);C(this,"_minBufferSize",0)}finalize(e){e&&this._append(e);const n=this._nDataBytes*8,a=this._data.sigBytes*8;return this._data.words[a>>>5]|=128<<24-a%32,this._data.words[(a+64>>>9<<4)+14]=Math.floor(n/4294967296),this._data.words[(a+64>>>9<<4)+15]=n,this._data.sigBytes=this._data.words.length*4,this._process(),this._hash}_doProcessBlock(e,n){const a=this._hash.words;let t=a[0],r=a[1],i=a[2],h=a[3],c=a[4],_=a[5],u=a[6],m=a[7];for(let o=0;o<64;o++){if(o<16)P[o]=e[n+o]|0;else{const D=P[o-15],g=(D<<25|D>>>7)^(D<<14|D>>>18)^D>>>3,f=P[o-2],d=(f<<15|f>>>17)^(f<<13|f>>>19)^f>>>10;P[o]=g+P[o-7]+d+P[o-16]}const v=c&_^~c&u,p=t&r^t&i^r&i,R=(t<<30|t>>>2)^(t<<19|t>>>13)^(t<<10|t>>>22),l=(c<<26|c>>>6)^(c<<21|c>>>11)^(c<<7|c>>>25),y=m+l+v+_e[o]+P[o],w=R+p;m=u,u=_,_=c,c=h+y|0,h=i,i=r,r=t,t=y+w|0}a[0]=a[0]+t|0,a[1]=a[1]+r|0,a[2]=a[2]+i|0,a[3]=a[3]+h|0,a[4]=a[4]+c|0,a[5]=a[5]+_|0,a[6]=a[6]+u|0,a[7]=a[7]+m|0}_append(e){typeof e=="string"&&(e=E.fromUtf8(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes}_process(e){let n,a=this._data.sigBytes/64;e?a=Math.ceil(a):a=Math.max((a|0)-this._minBufferSize,0);const t=a*16,r=Math.min(t*4,this._data.sigBytes);if(t){for(let i=0;i<t;i+=16)this._doProcessBlock(this._data.words,i);n=this._data.words.splice(0,t),this._data.sigBytes-=r}return new E(n,r)}}class E{constructor(e,n){C(this,"words");C(this,"sigBytes");e=this.words=e||[],this.sigBytes=n===void 0?e.length*4:n}static fromUtf8(e){const n=unescape(encodeURIComponent(e)),a=n.length,t=[];for(let r=0;r<a;r++)t[r>>>2]|=(n.charCodeAt(r)&255)<<24-r%4*8;return new E(t,a)}toBase64(){const e=[];for(let n=0;n<this.sigBytes;n+=3){const a=this.words[n>>>2]>>>24-n%4*8&255,t=this.words[n+1>>>2]>>>24-(n+1)%4*8&255,r=this.words[n+2>>>2]>>>24-(n+2)%4*8&255,i=a<<16|t<<8|r;for(let h=0;h<4&&n*8+h*6<this.sigBytes*8;h++)e.push(me.charAt(i>>>6*(3-h)&63))}return e.join("")}concat(e){if(this.words[this.sigBytes>>>2]&=4294967295<<32-this.sigBytes%4*8,this.words.length=Math.ceil(this.sigBytes/4),this.sigBytes%4)for(let n=0;n<e.sigBytes;n++){const a=e.words[n>>>2]>>>24-n%4*8&255;this.words[this.sigBytes+n>>>2]|=a<<24-(this.sigBytes+n)%4*8}else for(let n=0;n<e.sigBytes;n+=4)this.words[this.sigBytes+n>>>2]=e.words[n>>>2];this.sigBytes+=e.sigBytes}}function ge(s){return new ve().finalize(s).toBase64()}function O(s){return ge(J(s))}const De=Symbol.for("nuxt:client-only"),we=s=>s==="defer"||s===!1;function be(...s){var R;const e=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&typeof s[0]!="object"&&!(typeof s[0]=="function"&&typeof s[1]=="function")&&s.unshift(e);let[n,a,t={}]=s;const r=M(()=>b(n));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof a!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const i=Q(),h=()=>B.value,c=(l,y,w)=>{if(y.isHydrating)return y.payload.data[l];if(w.cause!=="refresh:manual"&&w.cause!=="refresh:hook")return y.static.data[l]};t.server??(t.server=!0),t.default??(t.default=h),t.getCachedData??(t.getCachedData=c),t.lazy??(t.lazy=!1),t.immediate??(t.immediate=!0),t.deep??(t.deep=B.deep),t.dedupe??(t.dedupe="cancel"),t._functionName,i._asyncData[r.value];const _=t.getCachedData(r.value,i,{cause:"initial"});(R=i._asyncData[r.value])!=null&&R._init||(i._asyncData[r.value]=V(i,r.value,a,t,_));const u=i._asyncData[r.value];u._deps++;const m=()=>i._asyncData[r.value].execute({cause:"initial",dedupe:t.dedupe}),o=t.server!==!1&&i.payload.serverRendered;{let l=function(f){const d=i._asyncData[f];d!=null&&d._deps&&(d._deps--,d._deps===0&&(d==null||d._off(),d._init=!1,x(i,f),d.execute=()=>Promise.resolve(),i._asyncData[f].data.value=B.value))};const y=W();if(y&&o&&t.immediate&&!y.sp&&(y.sp=[]),y&&!y._nuxtOnBeforeMountCbs){y._nuxtOnBeforeMountCbs=[];const f=y._nuxtOnBeforeMountCbs;X(()=>{f.forEach(d=>{d()}),f.splice(0,f.length)}),Z(()=>f.splice(0,f.length))}const w=y&&(y._nuxtClientOnly||K(De,!1));o&&i.isHydrating&&(u.error.value||_!=null)?(u.pending.value=!1,u.status.value=u.error.value?"error":"success"):y&&!w&&(i.payload.serverRendered&&i.isHydrating||t.lazy)&&t.immediate?y._nuxtOnBeforeMountCbs.push(m):t.immediate&&m();const D=ee();if(t.watch){const f=z(t.watch,()=>{u._execute({cause:"watch",dedupe:t.dedupe})},{flush:"post"});D&&q(()=>f())}const g=z(r,(f,d)=>{var T,U;const S=((T=i._asyncData[d])==null?void 0:T.data.value)!==B.value;d&&l(d),(U=i._asyncData[f])!=null&&U._init||(i._asyncData[f]=V(i,f,a,t,t.getCachedData(f,i,{cause:"initial"}))),i._asyncData[f]._deps++,(t.immediate||S)&&i._asyncData[f].execute({cause:"initial",dedupe:t.dedupe})},{flush:"sync"});D&&q(()=>{g(),l(r.value)})}const v={data:j(()=>{var l;return(l=i._asyncData[r.value])==null?void 0:l.data}),pending:j(()=>{var l;return(l=i._asyncData[r.value])==null?void 0:l.pending}),status:j(()=>{var l;return(l=i._asyncData[r.value])==null?void 0:l.status}),error:j(()=>{var l;return(l=i._asyncData[r.value])==null?void 0:l.error}),refresh:(...l)=>i._asyncData[r.value].execute(...l),execute:(...l)=>i._asyncData[r.value].execute(...l),clear:()=>x(i,r.value)},p=Promise.resolve(i._asyncDataPromises[r.value]).then(()=>v);return Object.assign(p,v),p}function j(s){return M({get(){var e;return(e=s())==null?void 0:e.value},set(e){const n=s();n&&(n.value=e)}})}function x(s,e){e in s.payload.data&&(s.payload.data[e]=void 0),e in s.payload._errors&&(s.payload._errors[e]=B.errorValue),s._asyncData[e]&&(s._asyncData[e].data.value=void 0,s._asyncData[e].error.value=B.errorValue,s._asyncData[e].pending.value=!1,s._asyncData[e].status.value="idle"),e in s._asyncDataPromises&&(s._asyncDataPromises[e]&&(s._asyncDataPromises[e].cancelled=!0),s._asyncDataPromises[e]=void 0)}function Be(s,e){const n={};for(const a of e)n[a]=s[a];return n}function V(s,e,n,a,t){var _;(_=s.payload._errors)[e]??(_[e]=B.errorValue);const r=n,i=a.deep?$:F,h=t!=null,c={data:i(h?t:a.default()),pending:F(!h),error:A(s.payload._errors,e),status:F("idle"),execute:(u={})=>{if(s._asyncDataPromises[e]){if(we(u.dedupe??a.dedupe))return s._asyncDataPromises[e];s._asyncDataPromises[e].cancelled=!0}if(u.cause==="initial"||s.isHydrating){const o=u.cause==="initial"?t:a.getCachedData(e,s,{cause:u.cause??"refresh:manual"});if(o!=null)return s.payload.data[e]=c.data.value=o,c.error.value=B.errorValue,c.status.value="success",Promise.resolve(o)}c.pending.value=!0,c.status.value="pending";const m=new Promise((o,v)=>{try{o(r(s))}catch(p){v(p)}}).then(async o=>{if(m.cancelled)return s._asyncDataPromises[e];let v=o;a.transform&&(v=await a.transform(o)),a.pick&&(v=Be(v,a.pick)),s.payload.data[e]=v,c.data.value=v,c.error.value=B.errorValue,c.status.value="success"}).catch(o=>{if(m.cancelled)return s._asyncDataPromises[e];c.error.value=k(o),c.data.value=N(a.default()),c.status.value="error"}).finally(()=>{m.cancelled||(c.pending.value=!1,delete s._asyncDataPromises[e])});return s._asyncDataPromises[e]=m,s._asyncDataPromises[e]},_execute:de((...u)=>c.execute(...u),0,{leading:!0}),_default:a.default,_deps:0,_init:!0,_hash:void 0,_off:s.hook("app:data:refresh",async u=>{(!u||u.includes(e))&&await c.execute({cause:"refresh:hook"})})};return c}function pe(s,e,n){const[a={},t]=[{},e],r=M(()=>b(s)),i=M(()=>b(a.key)||"$f"+O([t,typeof r.value=="string"?r.value:"",...Ce(a)]));if(!a.baseURL&&typeof r.value=="string"&&r.value[0]==="/"&&r.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:h,lazy:c,default:_,transform:u,pick:m,watch:o,immediate:v,getCachedData:p,deep:R,dedupe:l,...y}=a,w=I({...ae,...y,cache:typeof a.cache=="boolean"?void 0:a.cache}),D={server:h,lazy:c,default:_,transform:u,pick:m,immediate:v,getCachedData:p,deep:R,dedupe:l,watch:o===!1?[]:[...o||[],w]};if(!v){let d=function(){D.immediate=!0};z(i,d,{flush:"sync",once:!0}),o&&z([...o,w],d,{flush:"sync",once:!0})}let g;return be(i,()=>{var U;(U=g==null?void 0:g.abort)==null||U.call(g,new DOMException("Request aborted as another request to the same endpoint was initiated.","AbortError")),g=typeof AbortController<"u"?new AbortController:{};const d=b(a.timeout);let S;return d&&(S=setTimeout(()=>g.abort(new DOMException("Request aborted due to timeout.","AbortError")),d),g.signal.onabort=()=>clearTimeout(S)),(a.$fetch||globalThis.$fetch)(r.value,{signal:g.signal,...w}).finally(()=>{clearTimeout(S)})},D)}function Ce(s){var n;const e=[((n=b(s.method))==null?void 0:n.toUpperCase())||"GET",b(s.baseURL)];for(const a of[s.params||s.query]){const t=b(a);if(!t)continue;const r={};for(const[i,h]of Object.entries(t))r[b(i)]=b(h);e.push(r)}if(s.body){const a=b(s.body);if(!a)e.push(O(a));else if(a instanceof ArrayBuffer)e.push(O(Object.fromEntries([...new Uint8Array(a).entries()].map(([t,r])=>[t,r.toString()]))));else if(a instanceof FormData)e.push(O(Object.fromEntries(a.entries())));else if(te(a))e.push(O(I(a)));else try{e.push(O(a))}catch{console.warn("[useFetch] Failed to hash body",a)}}return e}const Pe={base:"w-full max-w-(--ui-container) mx-auto px-4 sm:px-6 lg:px-8"},Se={__name:"Container",props:{as:{type:null,required:!1},class:{type:null,required:!1}},setup(s){const e=s,n=se(),a=M(()=>{var t;return L({extend:L(Pe),...((t=n.ui)==null?void 0:t.container)||{}})});return(t,r)=>(re(),ne(N(ue),{as:s.as,class:oe(a.value({class:e.class}))},{default:ie(()=>[ce(t.$slots,"default")]),_:3},8,["as","class"]))}};var H=(s=>(s.RUB="RUB",s.USD="USD",s.EUR="EUR",s))(H||{});const Re="https://status.neuralgeneration.com/api/currency",Ue=le("currency",()=>{const s=$(H.RUB),e=$({});return{baseCurrency:s,rates:e,getRate:(t,r)=>{if(t===r)return 1;const i=`${t.toLowerCase()}-${r.toLowerCase()}`;return e.value[i]??0},fetchRates:async()=>{const{data:t}=await pe(Re,"$0szwYnzU0b");e.value=t.value}}});export{H as C,Se as _,Ue as u};
